---
title: Coding in Stan
output:
  html_document:
    toc: true
    toc_float: true
---

```{r}
library(rstan)
library(dplyr)
library(ggplot2)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```

```{r}
d <- readRDS("data/pcod-growth.rds")
d$i <- seq_len(nrow(d))
ggplot(d, aes(age, length)) + geom_point() +
  facet_wrap(~survey)
```

```{r}
dat <- list(
  N = nrow(d),
  length = d$length,
  age = d$age,
  prior_sds = c(k = 1, linf = 200, t0 = 1, sigma = 10),
  prior_only = 0
)
```

```{r}
mod <- stan_model("vb/vb_norm.stan")
fit1 <- sampling(mod, data = dat, iter = 1000, chains = 4, seed = 9129)
```

```{r}
print(fit1, pars = c("k", "linf", "t0", "sigma"))
```

```{r}
sims_list <- extract(fit1)
names(sims_list)

sims_matrix <- as.matrix(fit1)
dim(sims_matrix)
colnames(sims_matrix)[1:4]

sims_array <- as.array(fit1)
dim(sims_array)
colnames(sims_array[1,,])[1:4]

sims_df <- as.data.frame(fit1)
head(sims_df[,1:4])
```

```{r}
dim(sims_array)
bayesplot::mcmc_trace(sims_array[,,1:4])
```

Posterior predictions of new observations:

```{r}
post <- tidybayes::gather_draws(fit1, length_sim[i], ndraws = 20, seed = 9283)
head(post)

# column 'i' was previously added to our data above
post <- left_join(post, d)
ggplot(post, aes(age, .value)) + geom_point(alpha = 0.2)
```

Expected length values:

```{r}
post <- tidybayes::gather_draws(fit1, predicted_length[i], ndraws = 20, seed = 9283)
head(post)

post <- left_join(post, d)
ggplot(post, aes(age, .value, group = .draw)) + geom_line(alpha = 0.2) +
  geom_point(data = d, mapping = aes(age, length), inherit.aes = FALSE, alpha = 0.2)
```

The parameters themselves:

```{r}
post <- tidybayes::gather_draws(fit1, c(k, linf, t0, sigma))
head(post)
ggplot(post, aes(.value)) + geom_histogram() +
  facet_wrap(~.variable, scales = "free_x")
```

We can calculate ELPD of a leave-one-out approximation because we included `log_lik` in our `generated quantities` section. It's not all that useful yet though, since we've only fit one model.

```{r}
loo1 <- loo(fit1)
loo1
```

# Exercise

Take the above model and modify it to allow for separate k, linf, and t0 by survey region (HS vs. WCVI). Share the observation error SD. Ask whether LOO ELPD favours us estimating separate regions or defining them as one stock (according to this criteria).

```{r}
mod2 <- stan_model("vb/vb_norm_regions.stan")
dat2 <- dat
levels(factor(d$survey))
unique(as.integer(factor(d$survey)))
dat2$survey_id <- as.integer(factor(d$survey))
dat2$N_surveys <- 2

fit2 <- sampling(mod2, data = dat2, iter = 1000, chains = 4, seed = 9129)
print(fit2, pars = c("k", "linf", "t0", "sigma"))
```

```{r}
sims2 <- extract(fit2)
```


Plot the 80% quantile credible interval of expected values and the posterior predictive distribution:

```{r}
dim(sims2$length_sim)
d$upr <- apply(sims2$length_sim, 2, quantile, probs = 0.9)
d$med <- apply(sims2$length_sim, 2, quantile, probs = 0.5)
d$lwr <- apply(sims2$length_sim, 2, quantile, probs = 0.1)

d$e_upr <- apply(sims2$predicted_length, 2, quantile, probs = 0.9)
d$e_med <- apply(sims2$predicted_length, 2, quantile, probs = 0.5)
d$e_lwr <- apply(sims2$predicted_length, 2, quantile, probs = 0.1)

ggplot(d, aes(age, med, colour = survey, fill = survey)) + 
  geom_line() +
  geom_line(aes(y = e_med)) +
  geom_ribbon(aes(ymin = e_lwr, ymax = e_upr), alpha = 0.5, colour = NA) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, colour = NA) +
  geom_point(data = d, mapping = aes(age, length), inherit.aes = FALSE, alpha = 0.2) +
  ylab("Length") + xlab("Age")
```

```{r}
y <- d$length
sims1 <- extract(fit1)
sims2 <- extract(fit2)
set.seed(1)
i <- sample(1:nrow(sims1$length_sim), size = 20)
yrep1 <- sims1$length_sim[i,]
yrep2 <- sims2$length_sim[i,]
bayesplot::ppc_dens_overlay(y, yrep1)
bayesplot::ppc_dens_overlay(y, yrep2)

bayesplot::ppc_dens_overlay_grouped(y, yrep1, group = d$survey)
bayesplot::ppc_dens_overlay_grouped(y, yrep2, group = d$survey)
```

The `^` simply means the parameter must start with each of these patterns.
<https://xkcd.com/208/>

```{r}
sims_array2 <- as.array(fit2)[,,1:10]
bayesplot::mcmc_trace(sims_array2, regex_pars = c("^k", "^linf", "^t0", "^sigma"))
```

What does ELPD based on LOO cross validation tell us about the two models?

```{r}
loo2 <- loo(fit2)
loo::loo_compare(loo1, loo2)
```

We can compare the posterior distributions of parameters from the two surveys.

We will calculate differences for each of the parameters:

```{r}
sims <- extract(fit2)
dim(sims$k)
k_diff <- sims$k[,2] - sims$k[,1]
linf_diff <- sims$linf[,2] - sims$linf[,1]
t0_diff <- sims$t0[,2] - sims$t0[,1]
```

```{r}
hist(k_diff)
hist(linf_diff)
hist(t0_diff)
```

Using those posterior draws, answer the following questions:

What is the probability that linf is greater in WCVI than in HS?

```{r}
mean(linf_diff > 0)
```

What is the probability that linf is at least 5 cm greater in WCVI than in HS?

```{r}
mean(linf_diff > 5)
```

What is the probability that linf in WCVI is within 3 cm of HS?

```{r}
1 - mean(linf_diff > 3 | linf_diff < -3)
mean(linf_diff <= 3 & linf_diff >= -3)
```
